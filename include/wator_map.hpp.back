#pragma once

#include <algorithm>
#include <cstddef>
#include <cstdint>

#include <cassert>
#include <functional>
#include <memory>
#include <memory_resource>
#include <optional>
#include <random>
#include <vector>

#include <iostream>

#include "execution_planner.hpp"
#include "numa_allocator.hpp"
#include "wator_rules.hpp"

namespace WaTor {

class Map
{
    public:

    enum class Entity {
        WATER = 0,
        FISH,
        SHARK
    };

    class Tile {
    private:
        std::uint8_t m_lastAte:4,  m_age:4;

    public:

        static constexpr unsigned MAX_AGE = 14;
        static constexpr unsigned MAX_LAST_ATE = 14;

        void set(Entity ent, unsigned age, unsigned lastAte) {
            assert(age <= MAX_AGE && lastAte <= MAX_LAST_ATE);
            switch (ent) {
                case Entity::WATER:
                    assert(age == 0 && lastAte == 0);
                    m_lastAte = 0; m_age = 0;
                    break;
                case Entity::FISH:
                    assert(lastAte == 0 && age <= 14);
                    m_lastAte = 0; m_age = static_cast<std::uint8_t>(age+1);
                    break;
                case Entity::SHARK:
                    assert(lastAte <= 14 && age <= 14);
                    m_lastAte = static_cast<std::uint8_t>(lastAte+1); 
                    m_age = static_cast<std::uint8_t>(age+1);
                    break;
            }
        }


        Tile(Entity ent, unsigned age, unsigned lastAte) { // NOLINT
            set(ent, age, lastAte);
        }

        Tile() : Tile(Entity::WATER, 0, 0) {}

        [[nodiscard]] Entity getEntity() const {
            if(m_age == 0 && m_lastAte == 0) { return Entity::WATER; }
            if(m_lastAte == 0) { return Entity::FISH; }
            return Entity::SHARK;
        }

        [[nodiscard]] unsigned getAge() const { assert(m_age>0); return m_age-1; }
        [[nodiscard]] unsigned getLastAte() const { assert(m_lastAte>0); return m_lastAte-1; }
    };
    static_assert(sizeof(Tile) == 1, "Tile is large .. just large");

private:

    struct PerNumaData;

    struct PerMapLineData {
        std::size_t width, height;
        std::pmr::vector<bool> newUp, newDown, updated;
        std::pmr::vector<Tile> map;

        PerMapLineData(std::size_t width, std::size_t height, std::pmr::memory_resource *mmr) 
            : width(width), height(height),
              newUp(width, false, mmr), newDown(width, false, mmr), updated(width, false, mmr), 
              map(width*height, Tile(), mmr) {

            std::clog << "Creating line with: " << width << ' ' << height << '\n'; // TODO: comment out
        }

    };

    struct PerNumaData {
        NumaAllocator numaAllocRes;
        std::pmr::monotonic_buffer_resource allocRes;

        std::pmr::vector<PerMapLineData> lines;


        unsigned numaNode;

        // width, height of the map for this numaNode
        PerNumaData(unsigned width, unsigned height, unsigned curNode, const ExecutionPlanner &exp) 
            : numaAllocRes(curNode), allocRes(&numaAllocRes), lines(&allocRes), numaNode(curNode) {
            const std::vector<unsigned> &cpuList = exp.getCpuListPerNuma(curNode);
            unsigned cpuCnt = static_cast<unsigned>(cpuList.size());

            if(cpuCnt == 0) { return; }

            unsigned heightPerLine = height/(2*cpuCnt);
            unsigned heightRem = height - 2*cpuCnt*heightPerLine;

            lines.reserve(static_cast<std::size_t>(cpuCnt)*2);

            for(unsigned i=0; i<cpuCnt*2; ++i) {
                unsigned newHeight = heightPerLine;
                if(heightRem > 0) {
                    ++newHeight;
                    --heightRem;
                }

                lines.emplace_back(width, newHeight, &allocRes);
            }
        }
    };

    std::vector<std::unique_ptr<PerNumaData>> perNuma;

    // called inside constructor
    void fillRandom(const Rules &rules, unsigned seed) {
        struct Indx {
            unsigned numaInd;
            unsigned lineInd;
            size_t pos;
        };

        std::vector<Indx> indxList;
        indxList.reserve(rules.width*rules.height);

        for(unsigned numa=0; numa<perNuma.size(); ++numa) {
            for(unsigned line=0; line<perNuma[numa]->lines.size(); ++line) {
                for(std::size_t i=0; i<perNuma[numa]->lines[line].map.size(); ++i) {
                    indxList.emplace_back(numa, line, i);
                }
            }
        }

        std::mt19937 mtg(seed);
        std::shuffle(indxList.begin(), indxList.end(), mtg);
        indxList.resize(rules.initialFishCount + rules.initialSharkCount);

        Tile defFish{Entity::FISH, 0, 0};
        Tile defShark{Entity::SHARK, 0, 0};

        for(std::size_t i=0; i<rules.initialFishCount; ++i) {
            const Indx &indx = indxList[i];
            perNuma[indx.numaInd]->lines[indx.lineInd].map[indx.pos] = defFish;
        }
        for(std::size_t i=rules.initialFishCount; 
                i<rules.initialFishCount+rules.initialSharkCount; ++i) {
            const Indx &indx = indxList[i];
            perNuma[indx.numaInd]->lines[indx.lineInd].map[indx.pos] = defShark;
        }
    }

    //void generateNuma(unsigned numa, const ExecutionPlanner &exp) {
    //    
    //}

public:

    Map(Rules rules, const ExecutionPlanner &exp) {

        if(rules.height < 2*2*exp.getCpuCnt()) {
           throw std::runtime_error("Height is too small or CPU count is too large!");
        }

        unsigned numaNodeCnt = exp.isNuma() ? (exp.getNumaList().size()) : 1;

        perNuma.resize(numaNodeCnt);

        unsigned heightPerCpu = rules.height/(2*exp.getCpuCnt());
        unsigned heightRem = rules.height - 2*exp.getCpuCnt()*heightPerCpu;

        if(exp.isNuma()) {
            for(unsigned i=0; i<exp.getNumaList().size(); ++i) {
                unsigned numaNode = exp.getNumaList()[i];

                unsigned curNumaCpuCnt = static_cast<unsigned>(exp.getCpuListPerNuma(numaNode).size());
                unsigned newHeight = 2*heightPerCpu*curNumaCpuCnt;
                newHeight += std::min(curNumaCpuCnt, heightRem);
                heightRem -= std::min(curNumaCpuCnt, heightRem);

                perNuma[numaNode] = std::make_unique<PerNumaData>(rules.width, newHeight, numaNode, exp);
            }
        } else {
            unsigned numaNode = 0;

            unsigned curNumaCpuCnt = static_cast<unsigned>(exp.getCpuListPerNuma(numaNode).size());
            unsigned newHeight = 2*heightPerCpu*curNumaCpuCnt;
            newHeight += std::min(curNumaCpuCnt, heightRem);
            heightRem -= std::min(curNumaCpuCnt, heightRem);

            perNuma[numaNode] = std::make_unique<PerNumaData>(rules.width, newHeight, numaNode, exp);
        }
    }

    struct Cordinate {
        PerNumaData *numaData;
        unsigned numaInd;
        unsigned lineInNuma;
        unsigned posy, posx;
    };

    struct DirHelperData {
        std::pmr::vector<bool> *markNewLine;
        Cordinate cord;
    };

    // numaData == numaData[numaInd]
    [[nodiscard]] struct DirHelperData dirHelper(Cordinate cord, unsigned dir) const {
        DirHelperData res;
        int posy = static_cast<int>(cord.posy);
        int posx = static_cast<int>(cord.posy);
        
        constexpr int diry[] = {-1, 0, 1, 0};
        constexpr int dirx[] = {0, 1, 0, -1};

        int resY = posy + diry[dir];
        int resX = posx + dirx[dir];

        if(resX < 0) {
            resX = static_cast<int>(cord.numaData->lines[cord.lineInNuma].width-1);
        } else if(resX >= static_cast<int>(cord.numaData->lines[cord.lineInNuma].width-1)) {
            resX = 0;
        }

        int newNumaInd = static_cast<int>(cord.numaInd);
        int newLineInNuma = static_cast<int>(cord.lineInNuma);

        if(resY < 0)
        {
            --newLineInNuma;
            if(newLineInNuma < 0) {
                --newNumaInd;
                if(newNumaInd < 0) {
                    newNumaInd = static_cast<int>(perNuma.size()-1); 
                }
                newLineInNuma = static_cast<int>(perNuma[static_cast<unsigned>(newNumaInd)]->lines.size()-1);
            }
            resY = perNuma[static_cast<unsigned>(newNumaInd)]->lines[newLineInNuma].height-1;
        }

        if(resY >= cord.numaData->lines[newLineInNuma].height) {
            ++newLineInNuma;
            if(newLineInNuma >= cord.numaData->lines.size()) {
                ++newNumaInd;
                if(newNumaInd >= perNuma.size()) {
                    newNumaInd = 0;
                }

                newLineInNuma = 0;
            }

            resY = 0;
        }

        if(cord.numaInd == static_cast<unsigned>(newNumaInd)) {
            res.cord.numaData = cord.numaData;
        } else {
            res.cord.numaData = perNuma[newNumaInd].get();
        }

        res.cord.numaInd = newNumaInd;
        res.cord.lineInNuma = newLineInNuma;
        res.cord.posy = resY;
        res.cord.posx = resX;

        res.markNewLine = nullptr;
        if(cord.numaInd != static_cast<unsigned>(newNumaInd) || cord.lineInNuma != newLineInNuma) {
            if(dir == 0) {
                res.markNewLine = &res.cord.numaData->lines[res.cord.lineInNuma].newDown;
            } else if(dir == 2){
                res.markNewLine = &res.cord.numaData->lines[res.cord.lineInNuma].newUp;
            }
        }

        return res;
    }

    [[nodiscard]] Tile& get(const Cordinate &cord) {
        assert(perNuma[cord.numaInd].get() == cord.numaData);

        PerMapLineData &line = cord.numaData->lines[cord.lineInNuma];
        return line.map[line.width*cord.posy + cord.posx];
    }

    [[nodiscard]] const Tile& get(const Cordinate &cord) const {
        assert(perNuma[cord.numaInd].get() == cord.numaData);

        PerMapLineData &line = cord.numaData->lines[cord.lineInNuma];
        return line.map[line.width*cord.posy + cord.posx];
    }

    [[nodiscard]] std::pmr::vector<bool>& getUpdateBuf(const Cordinate &cord) {
        assert(perNuma[cord.numaInd].get() == cord.numaData);

        PerMapLineData &line = cord.numaData->lines[cord.lineInNuma];
        return line.updated;
    }

    [[nodiscard]] const std::pmr::vector<bool>& getUpdateBuf(const Cordinate &cord) const {
        assert(perNuma[cord.numaInd].get() == cord.numaData);

        PerMapLineData &line = cord.numaData->lines[cord.lineInNuma];
        return line.updated;
    }

    [[nodiscard]] std::pair<unsigned, unsigned> getWidthHeight(const Cordinate &cord) const {
        assert(perNuma[cord.numaInd].get() == cord.numaData);

        PerMapLineData &line = cord.numaData->lines[cord.lineInNuma];
        return std::make_pair(line.width, line.height);
    }

};

}
